---
title: "Unity GPU Jobs Analytics Report - PI Group"
format:
  html:
    theme: cosmo
    css: styles.css
    toc: true
    toc-depth: 3
    page-layout: article
    self-contained: true
params:
  pickle_file: null
---

```{python}
#| tags: [parameters]
#| echo: false

pickle_file = None
```

```{python}
#| echo: false
#| output: asis

# Import required libraries
import pandas as pd
import numpy as np
import pickle
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
import sys

# Add the project root to Python path so we can import from src
project_root = Path.cwd().parent  # Go up from reports directory to project root
sys.path.insert(0, str(project_root))

# Set up plotting style
plt.style.use('default')
sns.set_palette("husl")

# Load data from pickle file
with open(pickle_file, "rb") as f:
    data = pickle.load(f)

# Extract data
pi_account = data["pi_account"]
pi_metrics = data["pi_metrics"]
all_pi_metrics = data.get("all_pi_metrics", pi_metrics)  # Fallback to pi_metrics if not available
pi_users = data["pi_users"]
worst_users = data["worst_users"]
comparison_stats = data["comparison_stats"]
size_stats = data["size_stats"]
analysis_period = data["analysis_period"]
summary_stats = data["summary_stats"]
recommendations = data["recommendations"]

print(f"Report generated for PI Group: **{pi_account}**")
print()
print(f"Analysis period: **{analysis_period}**")
print()
print(f"Total users in group: {len(pi_users)}")
print()
print(f"Total jobs analyzed: {pi_metrics.iloc[0]['job_count'] if len(pi_metrics) > 0 else 'N/A'}")
```

```{python}
#| echo: false
#| output: asis

# Set the document title dynamically
from IPython.display import display, HTML
title_html = f"""
<script>
document.title = 'Unity GPU Jobs Analytics Report - PI Group {pi_account}';
</script>
"""
display(HTML(title_html))
```

---

## PI Group Performance Overview

```{python}
#| echo: false
#| output: asis

if len(pi_metrics) > 0:
    metrics = pi_metrics.iloc[0]

    # Calculate efficiency category using requested VRAM efficiency
    from src.config.enum_constants import EfficiencyCategoryEnum
    efficiency = metrics['expected_value_requested_vram_efficiency']
    efficiency_category = EfficiencyCategoryEnum.get_efficiency_category(efficiency)

    print(f"Your PI group's overall efficiency lies in the **{efficiency_category}** category.")
    print(f"The group uses **{efficiency:.1%}** of requested GPU memory on average.")
    print()

    # Group size assessment
    if metrics['user_count'] <= 3:
        size_assessment = "small"
    elif metrics['user_count'] <= 10:
        size_assessment = "medium-sized"
    else:
        size_assessment = "large"

    print(f"This is a **{size_assessment}** research group with **{metrics['user_count']}** active GPU users.")
    print(f"The group has consumed **{metrics['pi_acc_vram_hours']:.1f} VRAM-hours** and **{metrics['pi_acc_job_hours']:.1f} GPU-hours** in total.")

    # Performance insights
    if efficiency < 0.2:
        performance_msg = "âš ï¸ **Significant optimization needed** - Your group's efficiency is well below average."
    elif efficiency < 0.3:
        performance_msg = "ðŸŸ¡ **Room for improvement** - Consider optimizing memory usage patterns."
    elif efficiency < 0.5:
        performance_msg = "ðŸ“Š **Moderate performance** - Above critical thresholds but could be optimized."
    else:
        performance_msg = "ðŸŸ¢ **Good performance** - Your group is using GPU resources efficiently."

    print()
    print(performance_msg)
else:
    print("PI group metrics not available.")
```

---

## Key Statistics Summary

```{python}
#| echo: false

# Display the comprehensive summary table
if len(summary_stats) > 0:
    from IPython.display import display, HTML

    # Create a styled summary table
    table_html = summary_stats.to_html(
        index=False,
        escape=False,
        classes='table table-striped table-hover',
        table_id='pi-summary-table',
        border=0
    )

    # Add custom CSS styling
    styled_table = f"""
    <style>
    #pi-summary-table {{
        width: 100%;
        margin: 20px 0;
        border-collapse: collapse;
        font-family: Arial, sans-serif;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border-radius: 8px;
        overflow: hidden;
    }}
    #pi-summary-table th {{
        background-color: #1976D2;
        color: white;
        font-weight: bold;
        padding: 12px 15px;
        text-align: left;
        border: none;
    }}
    #pi-summary-table td {{
        padding: 12px 15px;
        border-bottom: 1px solid #ddd;
        background-color: #f9f9f9;
    }}
    #pi-summary-table tr:nth-child(even) td {{
        background-color: #f2f2f2;
    }}
    #pi-summary-table tr:hover td {{
        background-color: #e3f2fd;
    }}
    </style>
    {table_html}
    """

    display(HTML(styled_table))
else:
    print("ðŸ“‹ **PI Group Summary Statistics**")
    print("No summary statistics available.")
```

---

## Group Size and Resource Usage Analysis

```{python}
#| echo: false
#| output: asis

if size_stats:
    print("### How does your PI group compare in size?")
    print()

    # User count comparison (this is not in comparison_stats, it's calculated differently)
    # Calculate user count percentile manually since it's not provided in comparison_stats
    if 'all_pi_metrics' in locals() and len(all_pi_metrics) > 1:
        current_user_count = int(size_stats['user_count'])
        all_user_counts = all_pi_metrics['user_count']
        user_percentile = (all_user_counts < current_user_count).sum() / len(all_user_counts) * 100
    else:
        user_percentile = 50.0  # Default if no comparison data
        
    if user_percentile >= 90:
        user_size_msg = "ðŸ† **Top 10%** - One of the largest research groups"
    elif user_percentile >= 75:
        user_size_msg = "ðŸ“ˆ **Top 25%** - Larger than most groups"
    elif user_percentile >= 50:
        user_size_msg = "ðŸ“Š **Above median** - Medium-large sized group"
    elif user_percentile >= 25:
        user_size_msg = "ðŸ“‰ **Below median** - Smaller group"
    else:
        user_size_msg = "ðŸ” **Bottom 25%** - Small research group"

    print(f"**Group Size**: {size_stats['user_count']} users ({user_percentile:.1f}th percentile)")
    print()
    print(f"**Assessment**: {user_size_msg}")
    print()

    # Resource usage comparison (convert numpy type to Python type)
    vram_percentile = float(comparison_stats.get('vram_hours_percentile', 0))
    if vram_percentile >= 90:
        resource_msg = "ðŸ”¥ **Heaviest users** - Top 10% resource consumption"
    elif vram_percentile >= 75:
        resource_msg = "âš¡ **Heavy users** - Top 25% resource consumption"
    elif vram_percentile >= 50:
        resource_msg = "ðŸ“Š **Moderate usage** - Above average resource consumption"
    else:
        resource_msg = "ðŸ’¡ **Light usage** - Below average resource consumption"

    print(f"**Resource Usage**: {metrics['pi_acc_vram_hours']:.1f} VRAM-hours ({vram_percentile:.1f}th percentile)")
    print()
    print(f"**Assessment**: {resource_msg}")
    print()

    # Jobs comparison (convert numpy type to Python type)
    job_percentile = float(comparison_stats.get('job_count_percentile', 0))
    print(f"**Job Activity**: {metrics['job_count']} jobs ({job_percentile:.1f}th percentile)")
```

---

## Performance Comparison with Other PI Groups

```{python}
#| echo: false
#| output: asis
#| fig-cap: "PI Group Performance vs System Average"
#| fig-width: 14
#| fig-height: 8

if comparison_stats:
    # Display comparison statistics from the dictionary (convert numpy types to Python types)
    print("Your PI group compared to all other PI groups in the system:")
    print()
    
    efficiency_pct = float(comparison_stats.get('efficiency_percentile', 0))
    vram_pct = float(comparison_stats.get('vram_hours_percentile', 0))
    job_pct = float(comparison_stats.get('job_count_percentile', 0))
    efficiency_rank = int(comparison_stats.get('efficiency_rank', 0))
    total_groups = int(comparison_stats.get('total_pi_groups', 0))
    
    print(f"**Efficiency Ranking**: {efficiency_rank} out of {total_groups} PI groups ({efficiency_pct:.1f}th percentile)")
    print()
    print(f"**VRAM Hours Usage**: {vram_pct:.1f}th percentile")
    print()
    print(f"**Job Count**: {job_pct:.1f}th percentile")
    print()
    
    avg_eff = comparison_stats.get('avg_efficiency_all_groups', 0)
    median_eff = comparison_stats.get('median_efficiency_all_groups', 0)
    print(f"**System-wide averages**: Mean efficiency {avg_eff:.1%}, Median efficiency {median_eff:.1%}")
    
    # Create efficiency comparison plot
    fig, ax = plt.subplots(1, 1, figsize=(8, 6))
    
    # Get efficiency values from the actual data (convert numpy types to Python types)
    pi_efficiency = float(pi_metrics.iloc[0]['expected_value_requested_vram_efficiency']) * 100  # Convert to percentage
    system_avg_efficiency = float(comparison_stats.get('avg_efficiency_all_groups', 0)) * 100
    system_median_efficiency = float(comparison_stats.get('median_efficiency_all_groups', 0)) * 100
    
    categories = ['Your PI Group', 'System Average', 'System Median']
    efficiencies = [pi_efficiency, system_avg_efficiency, system_median_efficiency]
    colors = ['#1976D2', '#FFA726', '#66BB6A']
    
    bars = ax.bar(categories, efficiencies, color=colors, alpha=0.8, edgecolor='black')
    ax.axhline(30, color='red', linestyle='--', alpha=0.7, label='Good Efficiency Threshold (30%)')
    ax.set_ylabel('VRAM Efficiency (%)')
    ax.set_title('VRAM Efficiency Comparison')
    ax.set_ylim(0, max(max(efficiencies), 40) * 1.2)
    ax.legend()
    ax.grid(True, alpha=0.3, axis='y')
    
    # Add value labels on bars
    for bar, eff in zip(bars, efficiencies):
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2., height + max(max(efficiencies), 5) * 0.05,
                f'{eff:.1f}%', ha='center', va='bottom', fontweight='bold')
    
    plt.xticks(rotation=15)
    plt.tight_layout()
    plt.show()
    
    # Create VRAM hours comparison plot
    fig, ax = plt.subplots(1, 1, figsize=(8, 6))
    
    # Get VRAM hours values from the actual data (convert numpy types to Python types)
    pi_vram_hours = float(pi_metrics.iloc[0]['pi_acc_vram_hours'])
    # Calculate system average VRAM hours using all PI groups data
    if 'all_pi_metrics' in locals() and len(all_pi_metrics) > 1:
        system_avg_vram_hours = float(all_pi_metrics['pi_acc_vram_hours'].mean())
    else:
        system_avg_vram_hours = pi_vram_hours  # Fallback if only one group
    
    categories = ['Your PI Group', 'System Average']
    vram_hours = [pi_vram_hours, system_avg_vram_hours]
    colors = ['#1976D2', '#FFA726']
    
    bars = ax.bar(categories, vram_hours, color=colors, alpha=0.8, edgecolor='black')
    ax.set_ylabel('VRAM Hours')
    ax.set_title('VRAM Hours Usage Comparison')
    ax.grid(True, alpha=0.3, axis='y')
    
    # Add value labels on bars
    for bar, hours in zip(bars, vram_hours):
        height = bar.get_height()
        if max(vram_hours) > 0:
            ax.text(bar.get_x() + bar.get_width()/2., height + max(vram_hours) * 0.01,
                    f'{hours:.0f}', ha='center', va='bottom', fontweight='bold')
    
    plt.xticks(rotation=15)
    plt.tight_layout()
    plt.show()

else:
    print("No comparison data available.")
```

---

## Worst Performing Users in Your Group

<div style="margin: 20px 0; padding: 15px; background-color: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">
<h5 style="color: #856404; margin-bottom: 8px;">ðŸŽ¯ Focus Areas for Improvement</h5>
<p>The following analysis identifies users in your PI group who might benefit from additional GPU optimization guidance. These users show lower efficiency patterns that could be improved with targeted recommendations.</p>
</div>

```{python}
#| echo: false
#| output: asis
#| fig-cap: "VRAM Efficiency by User"
#| fig-width: 10
#| fig-height: 6

if len(worst_users) > 0:
    # Prepare data
    users = worst_users['User']
    efficiencies = worst_users['expected_value_requested_vram_efficiency'] * 100  # Convert to percentage
    vram_hours = worst_users['vram_hours']
    job_counts = worst_users['job_count']
    job_hours = worst_users['user_job_hours']

    # Colors for consistency
    colors = plt.cm.Set3(np.linspace(0, 1, len(users)))

    # Plot 1: VRAM Efficiency
    fig, ax = plt.subplots(1, 1, figsize=(10, 6))
    bars = ax.bar(range(len(users)), efficiencies, color=colors, alpha=0.8)
    ax.set_title('VRAM Efficiency by User', fontweight='bold')
    ax.set_ylabel('VRAM Efficiency (%)')
    ax.set_xticks(range(len(users)))
    ax.set_xticklabels(users, rotation=45, ha='right')
    ax.grid(True, alpha=0.3, axis='y')

    # Add efficiency threshold line
    ax.axhline(y=30, color='red', linestyle='--', alpha=0.7, label='Good Efficiency Threshold (30%)')
    ax.legend()

    # Add value labels
    for i, (bar, eff) in enumerate(zip(bars, efficiencies)):
        ax.text(bar.get_x() + bar.get_width()/2., bar.get_height() + max(max(efficiencies), 5) * 0.05,
               f'{eff:.1f}%', ha='center', va='bottom', fontweight='bold')

    plt.tight_layout()
    plt.show()
else:
    print("No user performance data available for analysis.")
```

```{python}
#| echo: false
#| output: asis
#| fig-cap: "VRAM Hours by User"
#| fig-width: 10
#| fig-height: 6

if len(worst_users) > 0:
    # Plot 2: VRAM Hours
    fig, ax = plt.subplots(1, 1, figsize=(10, 6))
    bars = ax.bar(range(len(users)), vram_hours, color=colors, alpha=0.8)
    ax.set_title('Total VRAM Hours by User', fontweight='bold')
    ax.set_ylabel('VRAM Hours')
    ax.set_xticks(range(len(users)))
    ax.set_xticklabels(users, rotation=45, ha='right')
    ax.grid(True, alpha=0.3, axis='y')

    # Add value labels
    for i, (bar, hours) in enumerate(zip(bars, vram_hours)):
        if max(vram_hours) > 0:
            ax.text(bar.get_x() + bar.get_width()/2., bar.get_height() + max(vram_hours) * 0.01,
                   f'{hours:.0f}', ha='center', va='bottom', fontweight='bold')

    plt.tight_layout()
    plt.show()
else:
    print("No VRAM hours data available for analysis.")
```

```{python}
#| echo: false
#| output: asis
#| fig-cap: "Job Count by User"
#| fig-width: 10
#| fig-height: 6

if len(worst_users) > 0:
    # Plot 3: Job Count
    fig, ax = plt.subplots(1, 1, figsize=(10, 6))
    bars = ax.bar(range(len(users)), job_counts, color=colors, alpha=0.8)
    ax.set_title('Number of Jobs by User', fontweight='bold')
    ax.set_ylabel('Job Count')
    ax.set_xticks(range(len(users)))
    ax.set_xticklabels(users, rotation=45, ha='right')
    ax.grid(True, alpha=0.3, axis='y')

    # Add value labels
    for i, (bar, count) in enumerate(zip(bars, job_counts)):
        if max(job_counts) > 0:
            ax.text(bar.get_x() + bar.get_width()/2., bar.get_height() + max(job_counts) * 0.01,
                   f'{count}', ha='center', va='bottom', fontweight='bold')

    plt.tight_layout()
    plt.show()
else:
    print("No job count data available for analysis.")
```

---

## Group User Distribution Analysis

```{python}
#| echo: false
#| output: asis
#| fig-cap: "User Performance Distribution in PI Group"
#| fig-width: 12
#| fig-height: 6

if len(pi_users) > 0:
    # Analyze user distribution within the PI group
    fig, ax1 = plt.subplots(1, 1, figsize=(8, 4))

    # Plot 1: Efficiency Distribution
    efficiencies = pi_users['expected_value_requested_vram_efficiency'] * 100
    ax1.hist(efficiencies, bins=min(10, len(pi_users)), alpha=0.7, color='#1976D2', edgecolor='black')
    ax1.axvline(efficiencies.mean(), color='red', linestyle='--',
               label=f'Group Mean: {efficiencies.mean():.1f}%')
    ax1.axvline(efficiencies.median(), color='orange', linestyle='--',
               label=f'Group Median: {efficiencies.median():.1f}%')
    ax1.axvline(30, color='green', linestyle='--', alpha=0.7,
               label='Good Efficiency (30%)')
    ax1.set_xlabel('VRAM Efficiency (%)')
    ax1.set_ylabel('Number of Users')
    ax1.set_title('Efficiency Distribution in PI Group')
    ax1.legend()
    ax1.grid(True, alpha=0.3)


    # User statistics
    print("### Group User Statistics")
    print()
    high_eff_users = sum(efficiencies >= 30)
    med_eff_users = sum((efficiencies >= 15) & (efficiencies < 30))
    low_eff_users = sum(efficiencies < 15)

    print(f"**High efficiency users** (â‰¥30%): {high_eff_users} ({high_eff_users/len(pi_users)*100:.1f}%)")
    print()
    print(f"**Medium efficiency users** (15-30%): {med_eff_users} ({med_eff_users/len(pi_users)*100:.1f}%)")
    print()
    print(f"**Low efficiency users** (<15%): {low_eff_users} ({low_eff_users/len(pi_users)*100:.1f}%)")

else:
    print("No user data available for distribution analysis.")
```

---

## Recommendations for PI Group

```{python}
#| echo: false
#| output: asis

if recommendations and len(recommendations) > 0:
    print("### ðŸŽ¯ Targeted Recommendations for Your PI Group")
    print()
    for i, rec in enumerate(recommendations, 1):
        print(f"{i}. {rec}")
        print()
else:
    # Generate default recommendations based on available data
    print("### ðŸ’¡ General Recommendations for PI Groups")
    print()

    if len(pi_metrics) > 0:
        metrics = pi_metrics.iloc[0]
        efficiency = metrics['expected_value_requested_vram_efficiency']

        if efficiency < 0.2:
            print("1. **Critical Efficiency Issue**: Your group's efficiency is very low. Consider organizing GPU optimization workshops for your users.")
            print()
            print("2. **Resource Planning**: Review whether all jobs actually need GPUs, and consider CPU-only alternatives for some workloads.")
            print()
        elif efficiency < 0.3:
            print("1. **Efficiency Improvement**: Focus on optimizing memory usage patterns across your group members.")
            print()
            print("2. **Best Practices Sharing**: Identify your most efficient users and have them share their optimization strategies.")
            print()

        if len(worst_users) > 0:
            print(f"3. **Targeted Training**: Focus on helping {len(worst_users)} users who show the lowest efficiency patterns.")
            print()

        if metrics['user_count'] > 10:
            print("4. **Group Coordination**: Consider implementing group-wide GPU usage guidelines due to your large group size.")
            print()

    print("5. **Regular Monitoring**: Set up periodic reviews of GPU usage patterns to maintain efficiency improvements.")
    print()
    print("6. **Resource Optimization**: Encourage batch size optimization and mixed precision training where applicable.")
```

---

## Additional Resources

For more information on optimizing your PI group's GPU usage:

1. [Unity HPC Documentation](https://docs.unity.rc.umass.edu/)
2. [GPU Programming Best Practices](https://docs.unity.rc.umass.edu/documentation/tools/gpus/)
3. [Contact Unity on Slack](https://docs.unity.rc.umass.edu/contact/community/)
4. **PI Group Training**: Contact Unity staff to arrange group training sessions on GPU optimization

---

## Detailed Performance Metrics

```{python}
#| echo: false

# Display detailed comparison table
if comparison_stats and len(comparison_stats) > 0:
    from IPython.display import display, HTML
    import pandas as pd

    # Convert comparison dictionary to DataFrame for display
    metrics = pi_metrics.iloc[0]
    all_vram_hours = float(all_pi_metrics['pi_acc_vram_hours'].mean())
    comparison_df = pd.DataFrame([
        {
            'Metric': 'VRAM Efficiency (%)', 
            'Your PI Group': f"{metrics.get('expected_value_requested_vram_efficiency', 0) * 100:.1f}%",
            'System Average': f"{comparison_stats.get('avg_efficiency_all_groups', 0) * 100:.1f}%"
        },
        {
            'Metric': 'Total VRAM Hours', 
            'Your PI Group': f"{metrics.get('pi_acc_vram_hours', 0):.0f}",
            'System Average': f"{all_vram_hours:.0f}"
        },
        {
            'Metric': 'User Count', 
            'Your PI Group': f"{metrics.get('user_count', 0)}",
            'System Average': f"{size_stats.get('avg_users_per_group', 0):.0f}"
        }
    ])

    # Create a comprehensive comparison table
    table_html = comparison_df.to_html(
        index=False,
        escape=False,
        classes='table table-striped table-hover',
        table_id='detailed-comparison-table',
        border=0
    )

    # Add custom CSS styling
    styled_table = f"""
    <style>
    #detailed-comparison-table {{
        width: 100%;
        margin: 20px 0;
        border-collapse: collapse;
        font-family: Arial, sans-serif;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border-radius: 8px;
        overflow: hidden;
    }}
    #detailed-comparison-table th {{
        background-color: #424242;
        color: white;
        font-weight: bold;
        padding: 12px 15px;
        text-align: left;
        border: none;
    }}
    #detailed-comparison-table td {{
        padding: 12px 15px;
        border-bottom: 1px solid #ddd;
        background-color: #f9f9f9;
    }}
    #detailed-comparison-table tr:nth-child(even) td {{
        background-color: #f2f2f2;
    }}
    #detailed-comparison-table tr:hover td {{
        background-color: #f5f5f5;
    }}
    </style>
    <h3>ðŸ“Š Detailed Performance Comparison</h3>
    {table_html}
    """

    display(HTML(styled_table))
```

---

*Report generated on `{python} datetime.now().strftime("%Y-%m-%d %H:%M:%S")` for PI Group: `{python} pi_account`*
