---
title: "Unity GPU Jobs Analytics Report"
format: 
  html:
    theme: cosmo
    css: styles.css
    toc: true
    toc-depth: 3
    page-layout: article
    self-contained: true
params:
  data_file: "user_data.json"
---

```{python}
#| tags: [parameters]
#| echo: false

data_file = "user_data.json"
```

```{python}
#| echo: false

# Import required libraries
import pandas as pd
import numpy as np
import json
import sys
import os
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path

# Add the project root to Python path so we can import from src
project_root = Path.cwd().parent  # Go up from reports directory to project root
sys.path.insert(0, str(project_root))

# Set up plotting style
plt.style.use('default')
sns.set_palette("husl")

# Load data from JSON file
try:
    with open(f"user_reports/temp/{data_file}", 'r') as f:
        data = json.load(f)
    
    # Extract all variables from the JSON data
    user_id = data['user_id']
    start_date = data['start_date']
    end_date = data['end_date']
    analysis_period = data['analysis_period']
    
    # Convert data back to DataFrames
    summary_stats_df = pd.DataFrame(data['summary_stats'])
    comparison_stats_df = pd.DataFrame(data['comparison_stats'])
    time_series_data_df = pd.DataFrame(data['time_series_data'])
    gpu_type_data_df = pd.DataFrame(data['gpu_type_data'])
    recommendations = data['recommendations']
    user_jobs = pd.DataFrame(data['user_jobs'])
    
    print(f"Report generated for user: {user_id}")
    print(f"Analysis period: {analysis_period}")
    print(f"Total jobs analyzed: {len(user_jobs)}")
    
except Exception as e:
    print(f"Error loading data: {e}")
    # Initialize fallback values
    user_id = "UNKNOWN"
    analysis_period = "Unknown"
    summary_stats_df = pd.DataFrame()
    comparison_stats_df = pd.DataFrame()
    time_series_data_df = pd.DataFrame()
    gpu_type_data_df = pd.DataFrame()
    recommendations = []
    user_jobs = pd.DataFrame()
```

```{python}
#| echo: false
#| output: asis

# Set the document title dynamically
from IPython.display import display, HTML
title_html = f"""
<script>
document.title = 'Unity GPU Jobs Analytics Report - {user_id}';
</script>
"""
display(HTML(title_html))
```


## GPU Jobs Analytics Report for `{python} user_id`

**Analysis Period:** `{python} analysis_period`

---

## Summary Statistics

```{python}
#| echo: false

# Display the summary statistics table
if len(summary_stats_df) > 0:
    # Style the table with HTML formatting
    from IPython.display import display, HTML
    
    # Create a styled HTML table
    table_html = summary_stats_df.to_html(
        index=False,
        escape=False,
        classes='table table-striped table-hover',
        table_id='summary-stats-table',
        border=0
    )
    
    # Add custom CSS styling to make it look better
    styled_table = f"""
    <style>
    #summary-stats-table {{
        width: 100%;
        margin: 20px 0;
        border-collapse: collapse;
        font-family: Arial, sans-serif;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border-radius: 8px;
        overflow: hidden;
    }}
    #summary-stats-table th {{
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
        padding: 12px 15px;
        text-align: left;
        border: none;
    }}
    #summary-stats-table td {{
        padding: 12px 15px;
        border-bottom: 1px solid #ddd;
        background-color: #f9f9f9;
    }}
    #summary-stats-table tr:nth-child(even) td {{
        background-color: #f2f2f2;
    }}
    #summary-stats-table tr:hover td {{
        background-color: #e8f5e8;
    }}
    </style>
    {table_html}
    """
    
    display(HTML(styled_table))
    
else:
    # Fallback minimal table if no data passed
    fallback_html = """
    <style>
    .fallback-table {
        width: 100%;
        margin: 20px 0;
        border-collapse: collapse;
        font-family: Arial, sans-serif;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border-radius: 8px;
        overflow: hidden;
    }
    .fallback-table th {
        background-color: #f44336;
        color: white;
        font-weight: bold;
        padding: 12px 15px;
        text-align: left;
    }
    .fallback-table td {
        padding: 12px 15px;
        background-color: #fff3e0;
        border-bottom: 1px solid #ddd;
    }
    </style>
    <table class="fallback-table">
        <thead>
            <tr>
                <th>Metric</th>
                <th>Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Data Status</td>
                <td>No summary statistics provided</td>
            </tr>
        </tbody>
    </table>
    """
    display(HTML(fallback_html))
```

### Performance Summary

```{python}
#| echo: false
#| output: asis

if len(summary_stats_df) > 0:
    # Extract key metrics from summary_stats_df for narrative
    try:
        # Get efficiency category and metrics from the table
        efficiency_row = summary_stats_df[summary_stats_df['Metric'].str.contains('efficiency category', case=False, na=False)]
        vram_usage_row = summary_stats_df[summary_stats_df['Metric'].str.contains('Average VRAM efficiency', case=False, na=False)]
        zero_usage_row = summary_stats_df[summary_stats_df['Metric'].str.contains('Zero usage jobs', case=False, na=False)]
        time_estimate_row = summary_stats_df[summary_stats_df['Metric'].str.contains('Time estimation', case=False, na=False)]
        cpu_gpu_ratio_row = summary_stats_df[summary_stats_df['Metric'].str.contains('CPU/GPU memory ratio', case=False, na=False)]
        
        # Generate narrative based on available data
        if not efficiency_row.empty:
            efficiency_category = efficiency_row.iloc[0]['Value']
            print(f"Your overall job's efficiency in this period lies in the **{efficiency_category}** category.")
        
        if not vram_usage_row.empty:
            vram_efficiency = vram_usage_row.iloc[0]['Value']
            print(f" Your GPU jobs use **{vram_efficiency}** of the requested GPU memory on average.")
        
        if not zero_usage_row.empty:
            zero_usage = zero_usage_row.iloc[0]['Value']
            if "0" not in str(zero_usage):
                print(f"\nâš ï¸ **{zero_usage}** of your jobs did not use any significant amount of GPU memory.")
            else:
                print("\nâœ“ All of your jobs are using GPU memory effectively.")
        
        if not time_estimate_row.empty:
            time_estimate = time_estimate_row.iloc[0]['Value']
            print(f"\nYou appear to have **{time_estimate}** the time limits for your jobs.")
        
        if not cpu_gpu_ratio_row.empty:
            cpu_gpu_ratio = cpu_gpu_ratio_row.iloc[0]['Value']
            try:
                ratio_value = float(str(cpu_gpu_ratio).split()[0])
                if ratio_value > 2.0:
                    print(f"\nâš ï¸ Your CPU to GPU memory usage ratio is high ({cpu_gpu_ratio}). This might indicate that your jobs are more CPU-intensive than GPU-intensive.")
            except:
                pass
                
    except Exception as e:
        print("Performance analysis data not available in expected format.")
else:
    print("No performance summary data provided.")
```

---

## Single-Column Visualizations

### GPU Memory Usage Distribution

```{python}
#| echo: false
#| fig-cap: "GPU Memory Usage Distribution"
#| fig-width: 10
#| fig-height: 6

if len(user_jobs) > 0 and 'used_vram_gib' in user_jobs.columns:
    try:
        from src.visualization.columns import ColumnVisualizer
        
        # Prepare the data for ColumnVisualizer (it expects GPUMemUsage column in bytes)
        user_jobs_viz = user_jobs.copy()
        user_jobs_viz['GPUMemUsage'] = user_jobs_viz['used_vram_gib'] * (2**30)  # Convert GiB to bytes
        
        # Initialize the visualizer with the user's job data
        visualizer = ColumnVisualizer(user_jobs_viz)
        
        # Use the visualize method to generate the GPU memory usage histogram
        visualizer.visualize(output_dir_path=None, columns=['GPUMemUsage'])
        
    except Exception as e:
        print(f"Error using ColumnVisualizer for GPU memory chart: {e}")
        # Fallback to simple histogram
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.histplot(data=user_jobs, x="used_vram_gib", bins=20, kde=True, color='blue', alpha=0.7, ax=ax)
        
        # Add average and median lines
        avg_usage = user_jobs["used_vram_gib"].mean()
        median_usage = user_jobs["used_vram_gib"].median()
        
        ax.axvline(x=avg_usage, color='red', linestyle='--', label=f'Average: {avg_usage:.2f} GiB')
        ax.axvline(x=median_usage, color='green', linestyle='--', label=f'Median: {median_usage:.2f} GiB')
        
        ax.set_xlabel('GPU Memory Used (GiB)')
        ax.set_ylabel('Number of Jobs')
        ax.set_title('Distribution of Your GPU Memory Usage')
        ax.legend()
        plt.tight_layout()
        plt.show()
else:
    print("GPU memory usage data not available.")
```

### Job Status Distribution

```{python}
#| echo: false
#| fig-cap: "Job Status Distribution"
#| fig-width: 8
#| fig-height: 6

if len(user_jobs) > 0 and 'Status' in user_jobs.columns:
    try:
        from src.visualization.columns import ColumnVisualizer
        
        # Initialize the visualizer with the user's job data
        visualizer = ColumnVisualizer(user_jobs)
        
        # Use the visualize method to generate the Status pie chart
        visualizer.visualize(output_dir_path=None, columns=['Status'])
        
    except Exception as e:
        print(f"Error using ColumnVisualizer for status chart: {e}")
        # Fallback to simple visualization
        status_counts = user_jobs['Status'].value_counts()
        plt.figure(figsize=(8, 6))
        plt.pie(status_counts.values, labels=status_counts.index, autopct='%1.1f%%', startangle=90)
        plt.title('Distribution of Job Statuses')
        plt.tight_layout()
        plt.show()
else:
    print("Job status data not available.")
```

### GPU Type Usage

```{python}
#| echo: false
#| fig-cap: "GPU Type Usage"
#| fig-width: 10
#| fig-height: 6

if len(user_jobs) > 0 and 'GPUType' in user_jobs.columns:
    try:
        from src.visualization.columns import ColumnVisualizer
        
        # Initialize the visualizer with the user's job data
        visualizer = ColumnVisualizer(user_jobs)
        
        # Use the visualize method to generate the GPUType bar plot
        visualizer.visualize(output_dir_path=None, columns=['GPUType'])
        
    except Exception as e:
        print(f"Error using ColumnVisualizer for GPU type chart: {e}")
        # Fallback using pre-calculated data if available
        if len(gpu_type_data_df) > 0:
            plt.figure(figsize=(10, 6))
            plt.pie(gpu_type_data_df['job_count'], labels=gpu_type_data_df['gpu_type'], autopct='%1.1f%%')
            plt.title('GPU Type Usage Distribution')
            plt.axis('equal')
            plt.show()
        else:
            print("No GPU type data available.")
else:
    print("No GPU type data available.")
```

---

## A100 GPU Analysis

```{python}
#| echo: false
#| output: asis

# Check if user has used A100 GPUs
def extract_gpu_type(gpu_type_val):
    """Extract GPU type from various data formats."""
    if isinstance(gpu_type_val, list) and len(gpu_type_val) > 0:
        return gpu_type_val[0]
    elif isinstance(gpu_type_val, dict) and len(gpu_type_val) > 0:
        return list(gpu_type_val.keys())[0]
    elif isinstance(gpu_type_val, str):
        return gpu_type_val
    else:
        return "unknown"

if len(user_jobs) > 0 and 'GPUType' in user_jobs.columns:
    # Extract primary GPU types
    user_jobs_a100 = user_jobs.copy()
    user_jobs_a100['primary_gpu_type'] = user_jobs_a100['GPUType'].apply(extract_gpu_type)
    
    # Filter for A100 jobs
    a100_jobs = user_jobs_a100[user_jobs_a100['primary_gpu_type'].str.contains('a100', case=False, na=False)]
    
    if len(a100_jobs) > 0:
        a100_percentage = (len(a100_jobs) / len(user_jobs)) * 100
        print(f"## A100 GPU Usage Analysis")
        print(f"You have used A100 GPUs in **{len(a100_jobs)}** out of **{len(user_jobs)}** jobs ({a100_percentage:.1f}%).")
        print()
    else:
        print("You have not used A100 GPUs in any of your analyzed jobs. This section is not applicable.")
        a100_jobs = pd.DataFrame()  # Set empty for conditional sections below
else:
    print("GPU type data not available for A100 analysis.")
    a100_jobs = pd.DataFrame()
```

### A100 vs Other GPU Performance Comparison

```{python}
#| echo: false
#| fig-cap: "A100 vs Other GPU Performance"
#| fig-width: 12
#| fig-height: 8

if len(a100_jobs) > 0 and len(user_jobs) > 0:
    try:
        # Create comparison between A100 and other GPUs
        user_jobs_comparison = user_jobs.copy()
        user_jobs_comparison['primary_gpu_type'] = user_jobs_comparison['GPUType'].apply(extract_gpu_type)
        user_jobs_comparison['is_a100'] = user_jobs_comparison['primary_gpu_type'].str.contains('a100', case=False, na=False)
        user_jobs_comparison['gpu_category'] = user_jobs_comparison['is_a100'].map({True: 'A100', False: 'Other GPUs'})
        
        # Calculate efficiency metrics by GPU category
        efficiency_metrics = user_jobs_comparison.groupby('gpu_category').agg({
            'alloc_vram_efficiency': 'mean' if 'alloc_vram_efficiency' in user_jobs_comparison.columns else lambda x: 0,
            'used_vram_gib': 'mean',
            'allocated_vram': 'mean',
            'job_hours': 'mean',
            'JobID': 'count'
        }).reset_index()
        
        if len(efficiency_metrics) > 1:  # Both A100 and other GPUs present
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 8))
            
            # 1. VRAM Efficiency Comparison
            ax1.bar(efficiency_metrics['gpu_category'], efficiency_metrics['alloc_vram_efficiency'], 
                   color=['#FF6B6B', '#4ECDC4'], alpha=0.8)
            ax1.set_title('Average VRAM Efficiency')
            ax1.set_ylabel('Efficiency')
            for i, v in enumerate(efficiency_metrics['alloc_vram_efficiency']):
                ax1.text(i, v + max(efficiency_metrics['alloc_vram_efficiency']) * 0.02, f'{v:.3f}', 
                        ha='center', va='bottom', fontweight='bold')
            
            # 2. Memory Usage Comparison
            ax2.bar(efficiency_metrics['gpu_category'], efficiency_metrics['used_vram_gib'], 
                   color=['#FF6B6B', '#4ECDC4'], alpha=0.8)
            ax2.set_title('Average GPU Memory Used')
            ax2.set_ylabel('Memory (GiB)')
            for i, v in enumerate(efficiency_metrics['used_vram_gib']):
                ax2.text(i, v + max(efficiency_metrics['used_vram_gib']) * 0.02, f'{v:.1f}', 
                        ha='center', va='bottom', fontweight='bold')
            
            # 3. Job Duration Comparison
            ax3.bar(efficiency_metrics['gpu_category'], efficiency_metrics['job_hours'], 
                   color=['#FF6B6B', '#4ECDC4'], alpha=0.8)
            ax3.set_title('Average Job Duration')
            ax3.set_ylabel('Hours')
            for i, v in enumerate(efficiency_metrics['job_hours']):
                ax3.text(i, v + max(efficiency_metrics['job_hours']) * 0.02, f'{v:.1f}', 
                        ha='center', va='bottom', fontweight='bold')
            
            # 4. Job Count
            ax4.bar(efficiency_metrics['gpu_category'], efficiency_metrics['JobID'], 
                   color=['#FF6B6B', '#4ECDC4'], alpha=0.8)
            ax4.set_title('Number of Jobs')
            ax4.set_ylabel('Job Count')
            for i, v in enumerate(efficiency_metrics['JobID']):
                ax4.text(i, v + max(efficiency_metrics['JobID']) * 0.02, f'{int(v)}', 
                        ha='center', va='bottom', fontweight='bold')
            
            plt.tight_layout()
            plt.show()
        else:
            print("Only one GPU type category available - comparison not possible.")
            
    except Exception as e:
        print(f"Error creating A100 comparison: {e}")
else:
    print("A100 comparison not available - insufficient A100 usage data.")
```

### A100 Efficiency Distribution

```{python}
#| echo: false
#| fig-cap: "A100 VRAM Efficiency Distribution"
#| fig-width: 10
#| fig-height: 6

if len(a100_jobs) > 0 and 'alloc_vram_efficiency' in a100_jobs.columns:
    try:
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # Histogram of A100 efficiency
        ax1.hist(a100_jobs['alloc_vram_efficiency'], bins=20, alpha=0.7, color='#FF6B6B', edgecolor='black')
        ax1.axvline(a100_jobs['alloc_vram_efficiency'].mean(), color='red', linestyle='--', 
                   label=f'Mean: {a100_jobs["alloc_vram_efficiency"].mean():.3f}')
        ax1.axvline(a100_jobs['alloc_vram_efficiency'].median(), color='orange', linestyle='--',
                   label=f'Median: {a100_jobs["alloc_vram_efficiency"].median():.3f}')
        ax1.set_xlabel('VRAM Efficiency')
        ax1.set_ylabel('Number of A100 Jobs')
        ax1.set_title('Distribution of A100 VRAM Efficiency')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # Efficiency over time for A100 jobs
        if 'StartTime' in a100_jobs.columns:
            a100_sorted = a100_jobs.sort_values('StartTime')
            ax2.scatter(a100_sorted['StartTime'], a100_sorted['alloc_vram_efficiency'], 
                       alpha=0.6, color='#FF6B6B', s=50)
            ax2.set_xlabel('Date')
            ax2.set_ylabel('VRAM Efficiency')
            ax2.set_title('A100 Job Efficiency Over Time')
            ax2.grid(True, alpha=0.3)
            
            # Add trend line
            if len(a100_sorted) > 1:
                from scipy import stats
                x_numeric = pd.to_numeric(pd.to_datetime(a100_sorted['StartTime']))
                slope, intercept, r_value, p_value, std_err = stats.linregress(x_numeric, a100_sorted['alloc_vram_efficiency'])
                line = slope * x_numeric + intercept
                ax2.plot(a100_sorted['StartTime'], line, 'r-', alpha=0.8, 
                        label=f'Trend (RÂ²={r_value**2:.3f})')
                ax2.legend()
        else:
            ax2.text(0.5, 0.5, 'No timestamp data available', ha='center', va='center', transform=ax2.transAxes)
            ax2.set_title('A100 Timeline Not Available')
        
        plt.tight_layout()
        plt.show()
        
    except Exception as e:
        print(f"Error creating A100 efficiency distribution: {e}")
        # Simple fallback
        print(f"A100 jobs summary:")
        print(f"- Total A100 jobs: {len(a100_jobs)}")
        if 'alloc_vram_efficiency' in a100_jobs.columns:
            print(f"- Average efficiency: {a100_jobs['alloc_vram_efficiency'].mean():.3f}")
            print(f"- Efficiency range: {a100_jobs['alloc_vram_efficiency'].min():.3f} - {a100_jobs['alloc_vram_efficiency'].max():.3f}")
else:
    print("A100 efficiency distribution not available - insufficient data.")
```

### A100 Usage Insights

```{python}
#| echo: false
#| output: asis

if len(a100_jobs) > 0:
    # Calculate A100-specific insights
    try:
        total_a100_hours = a100_jobs['job_hours'].sum() if 'job_hours' in a100_jobs.columns else 0
        avg_a100_efficiency = a100_jobs['alloc_vram_efficiency'].mean() if 'alloc_vram_efficiency' in a100_jobs.columns else 0
        avg_a100_memory = a100_jobs['used_vram_gib'].mean() if 'used_vram_gib' in a100_jobs.columns else 0
        a100_allocated_memory = a100_jobs['allocated_vram'].mean() if 'allocated_vram' in a100_jobs.columns else 0
        
        print("### Key A100 Insights")
        print()
        print(f"**A100 Resource Usage:**")
        print(f"- Total A100 GPU hours consumed: **{total_a100_hours:.1f} hours**")
        print(f"- Average memory utilization: **{avg_a100_memory:.1f} GiB** out of **{a100_allocated_memory:.1f} GiB** allocated")
        print(f"- Average VRAM efficiency: **{avg_a100_efficiency:.1%}**")
        print()
        
        # Efficiency assessment
        if avg_a100_efficiency < 0.2:
            efficiency_assessment = "**Low** - Consider if A100s are necessary for your workloads"
            efficiency_color = "ðŸ”´"
        elif avg_a100_efficiency < 0.5:
            efficiency_assessment = "**Moderate** - Room for improvement in memory utilization"
            efficiency_color = "ðŸŸ¡"
        else:
            efficiency_assessment = "**Good** - Efficient use of A100 resources"
            efficiency_color = "ðŸŸ¢"
        
        print(f"**A100 Efficiency Assessment:** {efficiency_color} {efficiency_assessment}")
        print()
        
        # Cost implications (approximate)
        if total_a100_hours > 0:
            # A100s are typically 4-8x more expensive than other GPUs
            other_jobs = user_jobs[~user_jobs.index.isin(a100_jobs.index)] if len(user_jobs) > len(a100_jobs) else pd.DataFrame()
            if len(other_jobs) > 0:
                other_hours = other_jobs['job_hours'].sum() if 'job_hours' in other_jobs.columns else 0
                a100_ratio = total_a100_hours / (total_a100_hours + other_hours) if other_hours > 0 else 1
                print(f"**Resource Distribution:**")
                print(f"- A100 hours: {total_a100_hours:.1f} ({a100_ratio:.1%} of total GPU hours)")
                print(f"- Other GPU hours: {other_hours:.1f} ({1-a100_ratio:.1%} of total GPU hours)")
                print()
        
        # Recommendations based on usage pattern
        print("**A100-Specific Recommendations:**")
        print()
        
        if avg_a100_efficiency < 0.3:
            print("- ðŸ”§ **Optimize Memory Usage**: Your A100 efficiency is low. Consider using batch size optimization or mixed precision training.")
            print("- ðŸ”„ **Consider Alternatives**: For jobs with low memory requirements, regular GPUs might be more cost-effective.")
        
        if avg_a100_memory < 20:  # Less than 20GB average usage
            print("- ðŸ“Š **Memory Underutilization**: You're using less than half of A100's memory capacity. Consider larger models or batch sizes.")
        
        if len(a100_jobs) < 5:
            print("- ðŸ“ˆ **Limited A100 Experience**: Consider experimenting with larger workloads that can fully utilize A100 capabilities.")
        else:
            print("- âœ… **Regular A100 User**: You're making good use of A100 resources. Continue optimizing for better efficiency.")
            
    except Exception as e:
        print(f"Error generating A100 insights: {e}")
        print("A100 insights could not be generated due to data processing issues.")
else:
    print("No A100 usage insights available.")
```

---

## Comparison with All Users

### VRAM Efficiency Comparison

```{python}
#| echo: false
#| fig-cap: "VRAM Efficiency Comparison"
#| fig-width: 10
#| fig-height: 6

if len(comparison_stats_df) > 0:
    # Create comparison visualization
    fig, ax = plt.subplots(figsize=(10, 6))
    
    categories = comparison_stats_df['Category']
    your_values = comparison_stats_df['Your_Value']
    avg_values = comparison_stats_df['Average_Value']
    
    x = np.arange(len(categories))
    width = 0.35
    
    bars1 = ax.bar(x - width/2, your_values, width, label='Your Performance', alpha=0.8)
    bars2 = ax.bar(x + width/2, avg_values, width, label='Average Performance', alpha=0.8)
    
    ax.set_xlabel('Performance Category')
    ax.set_ylabel('Value')
    ax.set_title('Your Performance vs. Average Users')
    ax.set_xticks(x)
    ax.set_xticklabels(categories, rotation=45, ha='right')
    ax.legend()
    
    # Add value labels on bars
    def autolabel(rects, values):
        for rect, value in zip(rects, values):
            height = rect.get_height()
            ax.annotate(f'{value:.1f}',
                       xy=(rect.get_x() + rect.get_width() / 2, height),
                       xytext=(0, 3),
                       textcoords="offset points",
                       ha='center', va='bottom')
    
    autolabel(bars1, your_values)
    autolabel(bars2, avg_values)
    
    plt.tight_layout()
    plt.show()
else:
    print("No comparison data available.")
```

### Time Usage Efficiency Comparison

```{python}
#| echo: false
#| fig-cap: "Time Usage Efficiency Comparison"
#| fig-width: 12
#| fig-height: 7

if len(comparison_stats_df) > 0:
    # Find time efficiency comparison
    time_comparison = comparison_stats_df[comparison_stats_df['Category'].str.contains('Time Usage', case=False, na=False)]
    
    if not time_comparison.empty:
        fig, ax = plt.subplots(figsize=(12, 7))
        
        categories = ['Your Time Usage', 'Average User Time Usage']
        values = [time_comparison.iloc[0]['Your_Value'], time_comparison.iloc[0]['Average_Value']]
        colors = ['#1f77b4', '#ff7f0e']
        
        # Create bars using matplotlib instead of seaborn
        bars = ax.bar(categories, values, color=colors, alpha=0.8, width=0.6)
        
        # Add value labels on bars
        for bar, value in zip(bars, values):
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height + max(values) * 0.01,
                   f'{value:.2f}%',
                   ha='center', va='bottom', fontsize=12, fontweight='bold')
        
        ax.set_ylabel('Time Usage (%)', fontsize=12)
        ax.set_title('Your Time Usage Efficiency vs. Average User', fontsize=14, fontweight='bold')
        ax.grid(True, alpha=0.3, axis='y')
        
        # Improve layout
        plt.subplots_adjust(bottom=0.15)
        ax.set_ylim(0, max(values) * 1.15)
        
        plt.tight_layout()
        plt.show()
        
        # Print values for debugging
        print(f"Your time usage efficiency: {values[0]:.2f}%")
        print(f"Average user time usage efficiency: {values[1]:.2f}%")
        
    else:
        print("Time usage comparison data not available.")
        print("Available comparison categories:")
        if len(comparison_stats_df) > 0:
            for cat in comparison_stats_df['Category'].tolist():
                print(f"  - {cat}")
else:
    print("No comparison statistics provided.")
```

### Total GPU Memory Usage Comparison

```{python}
#| echo: false
#| fig-cap: "Total GPU Memory Usage Comparison"
#| fig-width: 12
#| fig-height: 7

if len(comparison_stats_df) > 0:
    # Find total GPU memory comparison
    memory_comparison = comparison_stats_df[comparison_stats_df['Category'].str.contains('Total GPU Memory', case=False, na=False)]
    
    if not memory_comparison.empty:
        fig, ax = plt.subplots(figsize=(12, 7))
        
        categories = ['Your Total GPU Memory', 'Average User Total GPU Memory']
        values = [memory_comparison.iloc[0]['Your_Value'], memory_comparison.iloc[0]['Average_Value']]
        colors = ['#2ca02c', '#d62728']
        
        # Create bars using matplotlib instead of seaborn to avoid warnings
        bars = ax.bar(categories, values, color=colors, alpha=0.8, width=0.6)
        
        # Add value labels on bars
        for bar, value in zip(bars, values):
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height + max(values) * 0.01,
                   f'{value:.0f} GiB',
                   ha='center', va='bottom', fontsize=12, fontweight='bold')
        
        ax.set_ylabel('Total GPU Memory Used (GiB)', fontsize=12)
        ax.set_title('Your Total GPU Memory Usage vs. Average User', fontsize=14, fontweight='bold')
        ax.grid(True, alpha=0.3, axis='y')
        
        # Improve layout and spacing
        plt.subplots_adjust(bottom=0.15)
        ax.set_ylim(0, max(values) * 1.15)
        
        # Wrap long labels if needed
        ax.set_xticklabels(['Your Total\nGPU Memory', 'Average User\nTotal GPU Memory'])
        
        plt.tight_layout()
        plt.show()
        
        # Also print the values for debugging
        print(f"Your total GPU memory usage: {values[0]:.1f} GiB")
        print(f"Average user total GPU memory usage: {values[1]:.1f} GiB")
        
    else:
        print("Total GPU memory comparison data not available.")
        print("Available comparison categories:")
        if len(comparison_stats_df) > 0:
            for cat in comparison_stats_df['Category'].tolist():
                print(f"  - {cat}")
else:
    print("No comparison statistics provided.")
```

---

## Time Series Analysis

### VRAM Efficiency Over Time (Monthly)

```{python}
#| echo: false
#| fig-cap: "VRAM Efficiency Over Time - Monthly"
#| fig-width: 12
#| fig-height: 8

import matplotlib.pyplot as plt
import pandas as pd

if len(user_jobs) > 0 and 'StartTime' in user_jobs.columns:
    try:
        from src.analysis.frequency_analysis import FrequencyAnalysis
        from src.visualization.time_series import TimeSeriesVisualizer
        from src.config.enum_constants import TimeUnitEnum
        
        # Use frequency analysis to prepare monthly time series data
        frequency_analyzer = FrequencyAnalysis(user_jobs)
        
        # Prepare monthly time series data for the user
        monthly_data = frequency_analyzer.prepare_time_series_data(
            users=[user_id],
            metric="alloc_vram_efficiency" if "alloc_vram_efficiency" in user_jobs.columns else "used_vram_gib",
            time_unit=TimeUnitEnum.MONTHS,
            remove_zero_values=False
        )
        
        if len(monthly_data) > 0:
            # Map columns for TimeSeriesVisualizer
            monthly_data['Efficiency'] = monthly_data['Metric']
            monthly_data['GPU_Hours'] = monthly_data['GPUHours']
            
            # Create the time series visualizer
            ts_visualizer = TimeSeriesVisualizer(monthly_data)
            
            # Plot VRAM efficiency over time
            ts_visualizer.plot_vram_efficiency(
                users=[user_id],
                annotation_style="none",
                show_secondary_y=False
            )
        else:
            print("No monthly time series data available for this user.")
        
    except Exception as e:
        print(f"Error using FrequencyAnalysis for monthly time series: {e}")
        # Fallback to basic time series plot
        if 'StartTime' in user_jobs.columns:
            user_jobs_sorted = user_jobs.sort_values('StartTime').copy()
            
            # Group by month for fallback
            user_jobs_sorted['Month'] = pd.to_datetime(user_jobs_sorted['StartTime']).dt.to_period('M')
            monthly_avg = user_jobs_sorted.groupby('Month').agg({
                'alloc_vram_efficiency': 'mean' if 'alloc_vram_efficiency' in user_jobs_sorted.columns else lambda x: 0
            }).reset_index()
            
            if len(monthly_avg) > 0:
                plt.figure(figsize=(12, 6))
                plt.plot(monthly_avg['Month'].astype(str), monthly_avg['alloc_vram_efficiency'], 
                        marker='o', linewidth=2, markersize=6)
                plt.xlabel('Month')
                plt.ylabel('VRAM Efficiency')
                plt.title('VRAM Efficiency Over Time (Monthly Average)')
                plt.xticks(rotation=45)
                plt.grid(True, alpha=0.3)
                plt.tight_layout()
                plt.show()
            else:
                print("No time-based data available for efficiency analysis.")
else:
    print("No job data with timestamps available for time series analysis.")
```

### Individual Job Performance (Dot Plot)

```{python}
#| echo: false
#| fig-cap: "Individual Job Performance Over Time"
#| fig-width: 12
#| fig-height: 8

# Always show the dot plot for individual job performance
if len(user_jobs) > 0 and 'StartTime' in user_jobs.columns:
    try:
        from src.visualization.time_series import TimeSeriesVisualizer
        
        # Create time series visualizer with user job data
        ts_visualizer = TimeSeriesVisualizer(user_jobs)
        
        # Plot individual job performance as dots
        ts_visualizer.plot_vram_efficiency_per_job_dot(
            users=[user_id],
            efficiency_metric='alloc_vram_efficiency' if 'alloc_vram_efficiency' in user_jobs.columns else 'used_vram_gib',
            vram_metric='vram_hours' if 'vram_hours' in user_jobs.columns else 'job_hours',
            remove_zero_values=True
        )
        
    except Exception as e:
        print(f"Error creating dot plot: {e}")
        # Fallback scatter plot
        if 'alloc_vram_efficiency' in user_jobs.columns:
            plt.figure(figsize=(12, 6))
            plt.scatter(user_jobs['StartTime'], user_jobs['alloc_vram_efficiency'], 
                       alpha=0.6, s=50)
            plt.xlabel('Date')
            plt.ylabel('VRAM Efficiency')
            plt.title('Individual Job VRAM Efficiency Over Time')
            plt.xticks(rotation=45)
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            plt.show()
        else:
            print("VRAM efficiency data not available for individual job plot.")
else:
    print("No job data with timestamps available for dot plot.")
```

### Job Count Over Time

```{python}
#| echo: false
#| fig-cap: "Job Count Over Time"
#| fig-width: 12
#| fig-height: 6

if len(time_series_data_df) > 0:
    # Use the time series data for job count visualization
    if 'JobCount' in time_series_data_df.columns:
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Get the appropriate time column
        x_col = 'TimeGroup_Datetime' if 'TimeGroup_Datetime' in time_series_data_df.columns else 'TimeGroup_Str'
        
        # Convert to datetime if needed
        if x_col == 'TimeGroup_Datetime' and time_series_data_df[x_col].dtype == 'object':
            time_series_data_df[x_col] = pd.to_datetime(time_series_data_df[x_col])
        
        # Create a clean line plot with markers
        ax.plot(time_series_data_df[x_col], time_series_data_df['JobCount'], 
               marker='o', linewidth=2.5, markersize=8, color='#2E8B57', 
               markerfacecolor='#90EE90', markeredgecolor='#2E8B57', markeredgewidth=2)
        
        # Fill area under the curve for better visual appeal
        ax.fill_between(time_series_data_df[x_col], time_series_data_df['JobCount'], 
                       alpha=0.3, color='#90EE90')
        
        # Add horizontal line for average
        avg_jobs = time_series_data_df['JobCount'].mean()
        ax.axhline(y=avg_jobs, color='red', linestyle='--', alpha=0.7, 
                  label=f'Average: {avg_jobs:.1f} jobs')
        
        ax.set_xlabel('Time Period', fontsize=12)
        ax.set_ylabel('Number of Jobs', fontsize=12)
        ax.set_title('Job Submission Activity Over Time', fontsize=14, fontweight='bold')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Improve x-axis formatting
        if x_col == 'TimeGroup_Datetime':
            plt.xticks(rotation=45)
        else:
            # For string dates, show fewer labels to avoid crowding
            n_ticks = min(8, len(time_series_data_df))
            tick_indices = np.linspace(0, len(time_series_data_df)-1, n_ticks, dtype=int)
            ax.set_xticks([time_series_data_df[x_col].iloc[i] for i in tick_indices])
            plt.xticks(rotation=45)
        
        plt.tight_layout()
        plt.show()
    else:
        print("Job count data not available in time series.")
else:
    print("No time series data available for job count visualization.")
```

---

## Recommendations for Improvement

```{python}
#| echo: false
#| output: asis

if recommendations and len(recommendations) > 0:
    print("Based on your GPU usage patterns, here are some recommendations to improve efficiency:\n")
    for i, rec in enumerate(recommendations, 1):
        print(f"{i}. {rec}\n")
else:
    print("No specific recommendations provided. Generally, focus on optimizing GPU memory usage and time allocation for better efficiency.")
```

---

## Additional Resources

For more information on optimizing your GPU usage, please refer to these resources:

1. [Unity HPC Documentation](https://docs.unity.rc.umass.edu/)
2. [GPU Programming Best Practices](https://docs.unity.rc.umass.edu/documentation/tools/gpus/)
3. [Contact Unity on Slack](https://docs.unity.rc.umass.edu/contact/community/)

---

*Report generated on `{python} datetime.now().strftime("%Y-%m-%d %H:%M:%S")`*
